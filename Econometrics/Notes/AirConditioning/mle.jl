using ForwardDiff
using Optim
using CSV
using DataFrames

NumPlanes = 0
PlaneCounts = Dict{Int64,Int64}()
PlaneData = Vector{Vector{Float64}}



function ReadDataProcess( NumPlanes, PlaneCounts, PlaneData )
    #This function is a sin, but it reads the csv generated by Proschan and
    #Outputs the things I want.
    data = CSV.read("Proschan.csv", delim=',',header=["plane","data"] )

    i = 0
    curPlane = data[1,1]
    planecount = 0
    curPlaneIndex = 1

    for i = 1:size(data,1)
        if data[i,1] != curPlane
            PlaneCounts[curPlane] = i - curPlaneIndex
            curPlaneIndex = i
            NumPlanes += 1
            curPlane = data[i,1]
        end
    end

    PlaneCounts[curPlane] = i - curPlaneIndex
    NumPlanes += 1

    PlaneData = Vector{Vector{Float64}}(NumPlanes)
    RealPlaneCounts = Vector{Int64}(NumPlanes)

    planecounter = 1
    for planes in keys(PlaneCounts)
        PlaneData[planecounter] = Vector{Float64}()
        RealPlaneCounts[planecounter] = PlaneCounts[planes]
        PlaneCounts[planes] = planecounter
        planecounter += 1
    end

    for i = 1:size(data,1)
        push!(PlaneData[PlaneCounts[data[i,1]]],abs(data[i,2]))
    end

    return NumPlanes, RealPlaneCounts, PlaneData
end

NumPlanes, PlaneCounts, PlaneData = ReadDataProcess(NumPlanes, PlaneCounts, PlaneData)



function LogLiklihoodWeibull( x )
    # lambda = exp.(x[2:end])
     lambda = x[2:end]
    p = x[1]
   # p = exp(x[1])
    liklihood = 0

    for i = 1:NumPlanes
        for j = 1:PlaneCounts[i]
            liklihood -= p + lambda[i] +
                (exp(p)-1)*log((PlaneData[i])[j] ) - exp(lambda[i])*((PlaneData[i])[j]^exp(p))
        end
    end
    return liklihood
end

function GradLiklihoodWeibull(   x )
    #storage .= 0
    storage = zeros( NumPlanes + 1 )
    lambda = x[2:end]
    p = x[1]
    #lambda = exp.(x[2:end])
    #p = exp(x[1])
    for i = 1:NumPlanes
        for j = 1:PlaneCounts[i]
            #storage[1] -= (1/p) + log( (PlaneData[i])[j]) -
            #            lambda[i]*((PlaneData[i])[j]^p)*log( (PlaneData[i])[j])
            storage[1] -= 1 + exp(p)*log( (PlaneData[i])[j] ) - exp( lambda[i])*((PlaneData[i])[j]^exp(p))*log((PlaneData[i])[j])*exp(p)
            #storage[1+i] -= (1/lambda[i]) - ((PlaneData[i])[j]^p)
            storage[i+1] -= 1 - exp(lambda[i])*((PlaneData[i])[j]^exp(p))
        end
    end
    return storage
end

function HessLiklihoodWeibull(  x )
    lambda = x[2:end]#exp.(x[2:end])
    p = x[1]#exp( x[1] )
    storage = zeros( NumPlanes+1,NumPlanes+1)
    #storage .= 0


    for i = 1:NumPlanes
        for j = 1:PlaneCounts[i]
            storage[1,1] -= exp(p)*log((PlaneData[i])[j]) - exp(lambda[i])*((PlaneData[i])[j]^exp(p))*log((PlaneData[i])[j])^2 * exp(2p) - exp( lambda[i])*((PlaneData[i])[j]^exp(p))*log((PlaneData[i])[j])*exp(p)
            storage[1,i+1] -= -exp( lambda[i])*((PlaneData[i])[j]^exp(p))*log((PlaneData[i])[j])*exp(p)
            storage[1+i,1] -= -exp( lambda[i])*((PlaneData[i])[j]^exp(p))*log((PlaneData[i])[j])*exp(p)
            storage[1+i,i+1] -= -exp(lambda[i])*((PlaneData[i])[j]^exp(p))
        end
    end
    return storage
end





x = zeros( NumPlanes+1 )
#x = ones( NumPlanes+1)*log(.001)
# x[1] = 0

td = TwiceDifferentiable( LogLiklihoodWeibull, x, autodiff = :forward  )
minimizer = exp.(Optim.minimizer( optimize( td, x, method=Newton() ) ) )


g = x -> GradLiklihoodWeibull(x);
h = x -> HessLiklihoodWeibull(x);

iterations = 0
while norm( g(x) ) > .00001 && iterations < 100
    x = x - (h(x) \ g(x))
    iterations += 1
end



Minimizer = exp.( x )
